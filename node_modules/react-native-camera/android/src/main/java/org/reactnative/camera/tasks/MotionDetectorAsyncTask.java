package org.reactnative.camera.tasks;

import com.google.android.gms.vision.face.Face;
import org.reactnative.frame.RNFrame;
import org.reactnative.frame.RNFrameFactory;
import org.iopan.motiondetector.MotionDetector;

import com.facebook.react.bridge.ReadableMap;
import com.facebook.react.bridge.WritableMap;
import com.facebook.react.bridge.WritableArray;
import com.facebook.react.bridge.Arguments;
import android.graphics.Bitmap;
import android.graphics.Color;
import android.graphics.BitmapFactory;
import android.graphics.Matrix;
import android.util.SparseArray;

import com.google.zxing.BinaryBitmap;
import com.google.zxing.PlanarYUVLuminanceSource;

import android.content.res.Resources;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.lang.Throwable;
import android.os.Environment;

import org.reactnative.camera.utils.RNFileUtils;
import android.util.Log;
import java.lang.Math;
import android.util.Base64;


public class MotionDetectorAsyncTask extends android.os.AsyncTask<Void, Void, WritableMap> {
  private byte[] mImageData;
  private int mWidth;
  private int mHeight;
  private int mViewWidth;
  private int mViewHeight;
  private float mDensity;
  private int mRotation;
  private MotionDetector mMotionDetector;
  private MotionDetectorAsyncTaskDelegate mDelegate;

  private Bitmap motionPixelsFile;
  private int iGroup; 
  // private int[] curGroup;
  // private int nbPixInGroup;
  private SparseArray<Integer> curGroup;  

  // private SparseArray<SparseArray> groupedPixels;
  private boolean[][] breadcrumb;
  private    WritableMap returnValue  = Arguments.createMap();

  public MotionDetectorAsyncTask(
      MotionDetectorAsyncTaskDelegate delegate,
      MotionDetector motionDetector,
      byte[] imageData,
      int width,
      int height,
      int viewWidth,
      int viewHeight,
      float density,
      int rotation
  ) {
    mImageData = imageData;
    mWidth = width;
    mHeight = height;
    mViewWidth = viewWidth;
    mViewHeight = viewHeight;
    mDensity = density;
    mRotation = rotation;
    mDelegate = delegate;
    mMotionDetector = motionDetector;
  }

  @Override
  protected WritableMap doInBackground(Void... ignored) {
    if (mImageData==null || mViewWidth==0 || mViewHeight==0
    || isCancelled() || mDelegate == null || mMotionDetector == null || !mMotionDetector.isOperational()) {
      return null;
    }
    
    try {
      // Debug return.
      // returnValue.putString("pixelRatio", ""+mDensity);
      // returnValue.putString("cap", mWidth+"x"+mHeight);
      // returnValue.putString("view", mViewWidth+"x"+mViewHeight);
      // returnValue.putString("threshold",  String.format("0x%06X", mMotionDetector.mThreshold) );
      // returnValue.putString("Mode",  Integer.toBinaryString(mMotionDetector.mMode) );
      // returnValue.putString("sample size", ""+mMotionDetector.mSampleSize);
      // returnValue.putString("MinimumPixels",""+mMotionDetector.mMinimumPixels);
      // returnValue.putString("input Area",""+mMotionDetector.mArea);
      // returnValue.putString("mRotation",""+mRotation);

      boolean motionDetected = false;
      SparseArray<Integer> motionPixels = new SparseArray<Integer>();

      int[] rgb = decodeYUV420SP(mImageData, mWidth, mHeight);
      mImageData = null;

      Bitmap bitmap =  Bitmap.createBitmap(rgb, mWidth, mHeight, Bitmap.Config.ARGB_8888);
      if(bitmap==null){
        returnValue.putString("error","bitmap NULL");
        return returnValue;
      }
      rgb = null;

      bitmap = Bitmap.createScaledBitmap(
        rotateBitmap(bitmap,90),
        (int)((float)mViewWidth/(mDensity*mMotionDetector.mSampleSize)), 
        (int)((float)mViewHeight/(mDensity*mMotionDetector.mSampleSize)),
        false);

      int bitmapWidth = bitmap.getWidth();
      int bitmapHeight = bitmap.getHeight();
      // returnValue.putString("working on", bitmapWidth+"x"+bitmapHeight);

      // Create previous array if not exists.
      boolean firstRun = false;
      if (mMotionDetector.mPreviousSampledValues == null
      || mMotionDetector.mPreviousSampledValues.length != bitmapWidth*bitmapHeight){
        mMotionDetector.mPreviousSampledValues = new int[bitmapWidth*bitmapHeight];
        firstRun = true;
      }

      // Create bitmaps for base64 or file output.
      motionPixelsFile = Bitmap.createBitmap(bitmapWidth, bitmapHeight, Bitmap.Config.ARGB_8888);

      // Scan bitamp.
      int i = 0;
      scanBitmapLoop:
      for ( int x = 0; x < bitmapWidth; x++) {
        for ( int y = 0; y < bitmapHeight; y++) {

          if(mMotionDetector.mArea.equals("") || isInInputArea(x, y)){

            // Check differences with previously stored image.
            int color = bitmap.getPixel(x, y);
            if (!firstRun) {
              int previousColor = mMotionDetector.mPreviousSampledValues[i];

              int scoreRed = Math.abs(Color.red(previousColor) - Color.red(color)) - Color.red(mMotionDetector.mThreshold);
              int scoreGreen = Math.abs(Color.green(previousColor) - Color.green(color)) - Color.green(mMotionDetector.mThreshold);
              int scoreBlue = Math.abs(Color.blue(previousColor) - Color.blue(color)) - Color.blue(mMotionDetector.mThreshold);
              if (scoreRed>0 || scoreGreen>0 || scoreBlue>0){
                
                motionDetected = true;
                // We could stop here if denoising is not requested and if we are on run-mode.
                // if (mMotionDetector.mMinimumPixels < 2 && mMotionDetector.mMode == 0) {
                //   mMotionDetector.mPreviousSampledValues[i] = color;
                //   i++;
                //   break scanBitmapLoop;
                // }

                // Draw motion bitmap for base64 or file output.
                int score = Math.max(scoreRed, Math.max(scoreGreen,scoreBlue));
                score = score*2/3 + 85;

                int finalRed = scoreRed == Math.max(scoreRed, Math.max(scoreGreen,scoreBlue)) ? (0xff) : (0x00);
                int finalGreen = scoreGreen == Math.max(scoreRed, Math.max(scoreGreen,scoreBlue)) ? (0xff) : (0x00);
                int finalBlue = scoreBlue == Math.max(scoreRed, Math.max(scoreGreen,scoreBlue)) ? (0xff) : (0x00);
                motionPixelsFile.setPixel(x, y, (score) << 24 | finalRed << 16 | finalGreen << 8 | finalBlue);

                // Store motion pixel for denoising.
                motionPixels.put(motionPixels.size(), i);
              }
            }
            mMotionDetector.mPreviousSampledValues[i] = color;

          } // if is in input area
          i++;
          
        } // for y
      } // for x
      bitmap = null;

      // Denoising by grouping pixels and then excluding small groups.
      if (motionDetected && mMotionDetector.mMinimumPixels > 1){
        motionDetected = false;
        breadcrumb = new boolean[bitmapWidth][bitmapHeight];
        // groupedPixels = new SparseArray<SparseArray>();
        
        // Scan found motion pixels.
        for (i = 0; i < motionPixels.size(); i++) {
          int pixelInd = motionPixels.get(i);
          int y = pixelInd%bitmapHeight;
          int x = pixelInd/bitmapHeight;
   
          if(!breadcrumb[x][y]) {
            // nbPixInGroup = 0;
            // curGroup =  new int[bitmapHeight*bitmapWidth];
            curGroup =  new SparseArray<Integer>();
            int nbPixelsInGroup = groupPixel(x, y, 0, bitmapWidth, bitmapHeight);
            //returnValue.putString("group " + i , nbPixelsInGroup+"");
            if(nbPixelsInGroup < 0){
              // returnValue.putString("Denoising ERROR " + i , ""+iGroup);
            }
            else{
              // Erase small groups.
              if(nbPixelsInGroup < mMotionDetector.mMinimumPixels){

                // Scan current group and erase pixels on bitmap.
                // for (int iG = 0; iG<curGroup.size(); iG++){
                for (int iG = 0; iG<nbPixelsInGroup; iG++){
                  // int pixelIndex = curGroup[iG];
                  int pixelIndex = curGroup.get(iG);
                  int gx = pixelIndex%bitmapWidth;
                  int gy = pixelIndex/bitmapWidth;

                  motionPixelsFile.setPixel(gx, gy , 0);
                }
              }
              else {
                // Group is big enougth;
                motionDetected = true; 
              }
              iGroup++;
            }
          }
        } // scan motion pixels
      } // Denoising requested


      if (motionDetected) {
        if (mMotionDetector.mMode >= 0){
          // Pixelize motion bitmap.
          Bitmap pixelated  = getPixelatedResizedBitmap(
            motionPixelsFile, 
            (int)((float)mViewWidth / mDensity),
            (int)((float)mViewHeight / mDensity)
          );
          motionPixelsFile = pixelated;

          // Encode motion to base64 string.
          ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
          motionPixelsFile.compress(Bitmap.CompressFormat.PNG, 95, outputStream);
          String motionBase64 = Base64.encodeToString(outputStream.toByteArray(), Base64.DEFAULT);
          outputStream = null;
          returnValue.putString("motionBase64",motionBase64);
        }
      }
      else if (!mMotionDetector.mPreviousMotionDetected) {
        return null;
      }

      mMotionDetector.mPreviousMotionDetected = motionDetected;
      returnValue.putBoolean("motionDetected", motionDetected); 
      return returnValue;

    } catch (Throwable  e) {
      returnValue.putString("Error", e.getMessage()); 
      return returnValue;
    }

  }

  private boolean isInInputArea(int x, int y){
    String[] areaValues = mMotionDetector.mArea.split(";");
    int inputAreaLeft = Integer.parseInt(areaValues[1]);
    int inputAreaTop = Integer.parseInt(areaValues[2]);
    int inputAreaWidth = Integer.parseInt(areaValues[3]);
    int inputAreaHeight = Integer.parseInt(areaValues[4]);

    if (areaValues[0].equals("rectangle")) {
      if( x < inputAreaLeft
      ||  x > inputAreaLeft + inputAreaWidth -1
      ||  y < inputAreaTop 
      ||  y > inputAreaTop + inputAreaHeight -1
      ){
        return false;
      }
      else {
        return true;
      }
    }

    else { // elipse
      inputAreaWidth--;
      inputAreaHeight--;

      double ox = (double)inputAreaWidth/2 + (double)inputAreaLeft;
      double oy = (double)inputAreaHeight/2 + (double)inputAreaTop;
      double OF;
      double r1;
      double r2;

      if(inputAreaWidth >= inputAreaHeight){
        OF = Math.sqrt((double)
          (Math.pow(inputAreaWidth/2,2) - Math.pow(inputAreaHeight/2,2))
        );
        double f1x = ox-OF;
        double f2x = ox+OF;
        r1 = Math.sqrt(Math.pow(oy-y,2) + Math.pow(f1x-x, 2));
        r2 = Math.sqrt(Math.pow(oy-y,2) + Math.pow(f2x-x, 2));

        if(r1+r2 < inputAreaWidth){
          return true;
        }
      }
      else {
        OF = Math.sqrt((double)
          (Math.pow(inputAreaHeight/2,2) - Math.pow(inputAreaWidth/2,2))
        );
        double f1y = oy-OF;
        double f2y = oy+OF;
        r1 = Math.sqrt(Math.pow(ox-x,2) + Math.pow(f1y-y, 2));
        r2 = Math.sqrt(Math.pow(ox-x,2) + Math.pow(f2y-y, 2));

        if(r1+r2 <= inputAreaHeight){
          return true;
        }
      }
      return false;
    }     
  }

  private int groupPixel(int x,int y, int commingFrom, int  bitmapWidth, int bitmapHeight){
    try {
      Integer currentPixelIndex = x + y*bitmapWidth;
      SparseArray<Integer> toBeTreated = new SparseArray<Integer>();
      toBeTreated.put(toBeTreated.size(), currentPixelIndex);

      // Directions:
      // 5 1 2
      // 6 0 3
      // 7 8 4
      int[] direction =  {0,  5,   1,    2,    6,      3,    7,    8,    4  };
      int[] xs =         {0, -1,   0,    1,   -1,      1,   -1,    0,    1  };
      int[] ys =         {0, -1,  -1,   -1,    0,      0,    1,    1,    1  };

      int ip = 0;
      while (ip < toBeTreated.size() && ip<100){

        int pixelIndex = toBeTreated.get(ip);
        curGroup.put(curGroup.size(), pixelIndex);
        int x0 = pixelIndex % bitmapWidth;
        int y0 = pixelIndex / bitmapWidth;
        breadcrumb[x0][y0] = true;

        // Look for aside pixel to be treated.
        for (int i = 1; i<direction.length; i++){
          // ignore out of canvas pixels.
          if(x0+xs[i]>=0 && x0+xs[i]<bitmapWidth && y0+ys[i]>=0 && y0+ys[i]<bitmapHeight){

            if(!breadcrumb[x0+xs[i]][y0+ys[i]]){ 

              if(0 != motionPixelsFile.getPixel(x0+xs[i],y0+ys[i])) {
                // Found aside pixel in original image...
                toBeTreated.put(toBeTreated.size(), x0+xs[i] + (y0+ys[i])*bitmapWidth);
              }
            }
          }
        }
        ip++;
      }

      // pixelGroup[currentPixelIndex] = iGroup;
      // curGroup[curDeepth] = currentPixelIndex; 
      // groupedPixels.put(iGroup, curGroup);

      // return nbPixInGroup;
      return curGroup.size();

    } catch (Throwable  e) {
      returnValue.putString("groupPixel "+iGroup+" ERROR x:" + x+" y:"+y, " "+e);
      return -1;
    }
  }


  private int groupPixelRecursive(int x,int y, int commingFrom, int  bitmapWidth, int bitmapHeight){
    try {
      breadcrumb[x][y] = true;

      // nbPixInGroup++;
      // if (nbPixInGroup > mMotionDetector.mMinimumPixels){
      //   return nbPixInGroup;
      // }

      Integer currentPixelIndex = x + y*bitmapWidth;
      curGroup.put(curGroup.size(), currentPixelIndex);
      // if (curGroup.size() > mMotionDetector.mMinimumPixels){
      //   // return curGroup.size();
      // }

      // Directions:
      // 5 1 2
      // 6 0 3
      // 7 8 4
      int[] direction =  {0, 5,    1,    2,    6,      3,    7,    8,    4    };
      int[] xs =         {x, x-1,  x,    x+1,  x-1,    x+1,  x-1,  x,    x+1  };
      int[] ys =         {y, y-1,  y-1,  y-1,  y,      y,    y+1,  y+1,  y+1  };

      for (int i = 1; i<direction.length; i++){
        // ignore out of canvas pixels.
        if(xs[i]>=0 && xs[i]<bitmapWidth && ys[i]>=0 && ys[i]<bitmapHeight){
          // ignore comming from pixel.
          if(commingFrom != direction[i]  && !breadcrumb[xs[i]][ys[i]]){ 
            if(0 != motionPixelsFile.getPixel(xs[i],ys[i])) {
              // Found aside pixel in original image...
              groupPixel(xs[i],ys[i], 9-direction[i], bitmapWidth, bitmapHeight);    
            }
          }
        }
      }
    
      // pixelGroup[currentPixelIndex] = iGroup;
      // curGroup[curDeepth] = currentPixelIndex; 
      // groupedPixels.put(iGroup, curGroup);

      // return nbPixInGroup;
      return curGroup.size();

    } catch (Throwable  e) {
      // returnValue.putString("Denoising ERROR " + x+"+"+"y", ""+iGroup);
      return -1;
    }
  }

  @Override
  protected void onPostExecute(WritableMap motion) {
    super.onPostExecute(motion);

    if (motion == null) {
      // mDelegate.onMotionDetectionError(mMotionDetector);
    } else {
      // if (motion.size() > 0) {
        mDelegate.onMotionDetected(motion, mWidth, mHeight, mRotation);
      // }
    }
    mDelegate.onMotionDetectingTaskCompleted();
  }

  private Bitmap getPixelatedResizedBitmap(Bitmap bm, int newWidth, int newHeight) {
    int width = bm.getWidth();
    int height = bm.getHeight();
    float scaleWidth = ((float) newWidth) / width;
    float scaleHeight = ((float) newHeight) / height;
    // CREATE A MATRIX FOR THE MANIPULATION
    Matrix matrix = new Matrix();
    // RESIZE THE BIT MAP
    matrix.postScale(scaleWidth, scaleHeight);

    // "RECREATE" THE NEW BITMAP
    Bitmap resizedBitmap = Bitmap.createBitmap(
        bm, 0, 0, width, height, matrix, false);
    return resizedBitmap;
  }


  public int[] decodeYUV420SP( byte[] yuv420sp, int width, int height) {   

    final int frameSize = width * height;   

    int rgb[]=new int[width*height];   
    for (int j = 0, yp = 0; j < height; j++) {   
      int uvp = frameSize + (j >> 1) * width, u = 0, v = 0;   
      for (int i = 0; i < width; i++, yp++) {   
        int y = (0xff & ((int) yuv420sp[yp])) - 16;   
        if (y < 0) y = 0;   
        if ((i & 1) == 0) {   
            v = (0xff & yuv420sp[uvp++]) - 128;   
            u = (0xff & yuv420sp[uvp++]) - 128;   
        }   

        int y1192 = 1192 * y;   
        int r = (y1192 + 1634 * v);   
        int g = (y1192 - 833 * v - 400 * u);   
        int b = (y1192 + 2066 * u);   

        if (r < 0) r = 0; else if (r > 262143) r = 262143;   
        if (g < 0) g = 0; else if (g > 262143) g = 262143;   
        if (b < 0) b = 0; else if (b > 262143) b = 262143;   

        rgb[yp] = 0xff000000 | ((r << 6) & 0xff0000) | ((g >> 2) & 0xff00) | ((b >> 10) & 0xff);   
      }   
    }   
    return rgb;   
  } 

  public static Bitmap rotateBitmap(Bitmap source, float angle){
        Matrix matrix = new Matrix();
        matrix.postRotate(angle);
        return Bitmap.createBitmap(source, 0, 0, source.getWidth(), source.getHeight(), matrix, true);
  }
}

