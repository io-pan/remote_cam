package org.iopan.motiondetector;

import android.content.Context;
import android.util.SparseArray;

import org.reactnative.camera.utils.ImageDimensions;
import com.google.android.gms.vision.face.Face;
import org.reactnative.frame.RNFrame;

import com.facebook.react.bridge.Arguments;
import com.facebook.react.bridge.WritableMap;

public class MotionDetector {

  private ImageDimensions mPreviousDimensions;
  public int mMinimumPixels = 0;
  public int mMode = 1;
  public int mThreshold = 1;
  public int mSampleSize = 1;
  public String mArea = "";
  public int[] mPreviousSampledValues = null;
  public boolean mPreviousMotionDetected = false;

  public MotionDetector(Context context) {
    // mBuilder = new FaceDetection.Builder(context);
    // mBuilder.setMinFaceSize(mMinFaceSize);
    // mBuilder.setMode(mMode);
    // mBuilder.setLandmarkType(mLandmarkType);
    // mBuilder.setClassificationType(mClassificationType);
  }

  // Public API
  public boolean isOperational() {
    return true;
  }

  // DETECT
  public SparseArray<WritableMap> detect(RNFrame frame) {
    // If the frame has different dimensions, cxreate another face detection.
    // Otherwise we will get nasty "inconsistent image dimensions" error from detection
    // and no face will be detected.
    // if (!frame.getDimensions().equals(mPreviousDimensions)) {
    //   releaseMotionDetector();
    // }

    mPreviousMotionDetected = false;
    mPreviousDimensions = frame.getDimensions();
    
    SparseArray<WritableMap> maps = new SparseArray<>();
      WritableMap map = Arguments.createMap();
      map.putString("motion"," motion. detect");

    maps.put(0,map);
    return maps;
  
    // return mMotionDetector.detect(frame.getFrame());
  }

  public void setTracking(boolean trackingEnabled) {
    release();
  }

  public void setMinimumPixels(int pixelsNumber) {
    if (pixelsNumber != mMinimumPixels) {
      // release();
      mMinimumPixels = pixelsNumber;
    }
  }

  public void setArea(String area) {
    if (area != mArea) {
      // release();
      mArea = area;
    }
  }

  public void setMode(int mode) {
    if (mode != mMode) {
      // release();
      mMode = mode;
    }
  }

  public void setSampleSize(int size) {
    if (size != mSampleSize) {
      // release();
      mSampleSize = size;
    }
  }

  public void setThreshold(int threshold) {
    if (threshold != mThreshold) {
      // release();
      mThreshold = threshold;
    }
  }

  public void setTrackingEnabled(boolean tracking) {
    release();
  }

  public void release() {
    mPreviousDimensions = null;
    mPreviousMotionDetected = false;
  }

}
